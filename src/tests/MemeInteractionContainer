import { render, screen, fireEvent } from '@testing-library/react';
import { toast } from 'react-toastify';
import MemeInteractionContainer from '../Pages/MemeInteraction/MemeInteractionContainer';

// Mockowanie react-router-dom
jest.mock('react-router-dom', () => ({
  useParams: jest.fn().mockReturnValue({ id: '1' })
}));

// Mockowanie react-toastify
jest.mock('react-toastify', () => ({
  toast: {
    success: jest.fn(),
    error: jest.fn()
  }
}));

describe('MemeInteractionContainer', () => {
  beforeEach(() => {
    // Przygotowanie mocków dla każdego testu
    jest.resetAllMocks();
  });

  it('should render loading state', () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    render(<MemeInteractionContainer texts={{}} />);

    // Sprawdzenie czy wyświetla się stan ładowania
    expect(screen.getByText('Loading...')).toBeInTheDocument();
  });

  it('should handle successful meme fetch', () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    const fetchedMeme = {
      likeCount: 10,
      dislikeCount: 5,
      id: 1,
      url: 'https://example.com/meme.jpg',
      userReaction: {
        id: 'like'
      }
    };

    // Mockowanie odpowiedzi z useFetch
    jest.mock('../../hooks/useFetch', () => () => ({
      data: fetchedMeme,
      isLoading: false
    }));

    render(<MemeInteractionContainer texts={{}} />);

    // Sprawdzenie czy wyświetla się odpowiedni mem
    expect(screen.getByAltText('random meme')).toBeInTheDocument();
    expect(screen.getByText('10')).toBeInTheDocument();
    expect(screen.getByTestId('like-button')).toHaveTextContent('FilledLikeIcon');
  });

  it('should handle meme not found', () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    // Mockowanie odpowiedzi z useFetch
    jest.mock('../../hooks/useFetch', () => () => ({
      data: null,
      isLoading: false
    }));

    render(<MemeInteractionContainer texts={{}} />);

    // Sprawdzenie czy wyświetla się komunikat o nieznalezionym memie
    expect(screen.getByText('Meme not found')).toBeInTheDocument();
  });

  it('should handle copy button click', async () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    render(<MemeInteractionContainer texts={{ linkCopied: 'Link copied', linkCopiedError: 'Error copying link' }} />);

    // Mockowanie funkcji writeText z Clipboard API
    const writeTextMock = jest.fn();
    Object.assign(navigator, {
      clipboard: {
        writeText: writeTextMock
      }
    });

    // Kliknięcie przycisku do kopiowania
    fireEvent.click(screen.getByTestId('copy-button'));

    // Oczekiwanie na asynchroniczną operację kopiowania
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Sprawdzenie czy wywołano odpowiednie funkcje
    expect(writeTextMock).toHaveBeenCalledWith(window.location.href);
    expect(toast.success).toHaveBeenCalledWith('Link copied', { autoClose: 1000 });
  });

  it('should handle error while copying link', async () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    render(<MemeInteractionContainer texts={{ linkCopied: 'Link copied', linkCopiedError: 'Error copying link' }} />);

    // Mockowanie funkcji writeText z Clipboard API, aby zwrócić błąd
    const writeTextMock = jest.fn().mockRejectedValueOnce(new Error('Clipboard writeText error'));
    Object.assign(navigator, {
      clipboard: {
        writeText: writeTextMock
      }
    });

    // Kliknięcie przycisku do kopiowania
    fireEvent.click(screen.getByTestId('copy-button'));

    // Oczekiwanie na asynchroniczną operację kopiowania
    await new Promise((resolve) => setTimeout(resolve, 1000));

    // Sprawdzenie czy wywołano odpowiednie funkcje
    expect(writeTextMock).toHaveBeenCalledWith(window.location.href);
    expect(toast.error).toHaveBeenCalledWith('Error copying link', { autoClose: 1000 });
  });

  it('should handle failed meme fetch', () => {
    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useParams: jest.fn().mockReturnValue({ id: '1' })
    }));

    // Mockowanie odpowiedzi z useFetch
    jest.mock('../../hooks/useFetch', () => () => ({
      data: null,
      isLoading: false
    }));

    render(<MemeInteractionContainer texts={{}} />);

    // Sprawdzenie czy wyświetla się komunikat o błędzie ładowania mema
    expect(toast.error).toHaveBeenCalledWith('Failed to load meme', { autoClose: 2000 });
  });
});
